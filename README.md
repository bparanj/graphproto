## Development Environment

OS: Ubuntu 24.04.2 LTS
Node: v22.12.0

## My Learning Process

- Learn the concepts
- Design an axperiment
- Run the experiment
- Document the learning

Build lot of throw away code after the spike is completed. Reduce the number of unknowns so that the learned concepts becomes concrete. 

The aim is to get to the point of creating a good prompt for Claude so that it can design the experiment and provide the code. The challenge is guiding it to make the code and the design simple. For instance, I learned about the GraphQL basics from freecodecamp Youtube channel. So I knew how to reduce the amount of code and frameworks to focus on the essence. Otherwise it generates too much code that distracts from the learning and documentation process. 

## Graph Model Spike

The process begins with a simple use case. Pick a use case that is neither too big nor too small. Then sketch a one page paper prototype of the UI. Think of it as a simple widget that can be embedded in a MVP. Identify different terms in the paper prototype. Describe the use case in one paragraph. Identify the nouns and verbs in the description of the use case. Write down the relationship between the identified nodes and relationships. Draw a graph model on paper. 

Create a prompt for Claude to compare your graph model with the one generated by it. Work through the steps provided by Claude to implement a GraphQL API using Apollo Server, Node.js and Apollo Studio. The data is stored in a JSON file. We want to learn about these things:

- How to identify nodes and relationships required to implement the use case?
- How to iterate on the basic implementation end to end by using the GraphQL query interface?
- Does the graph model created by Claude sound like a domain model we can use in the project?

There are implementation of Apollo Server on other languages like Python, Go, Ruby etc. However the Nodejs implementation is maintained by the official Apollo GraphQL team and has the most stars on github. Eventhough I am more familiar with other languages, I decided to use Node implementation.

For a simple experiment it does not matter. We can document the learnings and throw away the code.

## Steps

### Step 1

I picked the simplest use case that is also not trivial for the first experiment:

Viewing balances across multiple bank accounts.

### Step 2

Create a paper prototype that displays the page with all the bank accounts and the total balance. The page shows what the user sees in one color and what each field means in a different color. 

### Step 3

Describe the relationships between the items that you see in the page in a paragraph. It does not have to be perfect. Some questions that I had: 

- Should there be a direct relationship between these two nodes? 
- Should I add an indirect relationship between these two nodes?

I jotted down the questions on the paper and moved on to the next step.

### Step 4

Draw a graph model from the description created in the previous step.

### Step 5

Now you can use the identified items in the prototype page to create a prompt. Prompt:

Identify the models needed for a graph database for a page that displays all the bank accounts for a user, the account type name and the balance. It also displays the total amount in all the bank accounts.

Compare the response with the graph model created on paper. This comparison will help you build your graph modeling muscle.

### Claude Instructions

To build a graph database for displaying bank accounts, account types, and balances, you need a data model that captures the relationships between users and their accounts. Here are the needed models:

## Entities

1. **User**
   - Properties:
     - `userId` (unique identifier)
     - `name`
     - `email`

2. **Account**
   - Properties:
     - `accountId` (unique identifier)
     - `balance` (numeric value)
     - `openDate` (when the account was created)

3. **AccountType**
   - Properties:
     - `typeId` (unique identifier)
     - `name` (e.g., "Checking", "Savings", "Investment")
     - `description`
     - `interestRate` (if applicable)

## Relationships

1. **OWNS**
   - Direction: User → Account
   - Properties: 
     - `accessLevel` (e.g., "primary", "joint", "authorized")

2. **IS_TYPE**
   - Direction: Account → AccountType
   - No additional properties needed

## Graph Structure

```
(User) -[OWNS]-> (Account) -[IS_TYPE]-> (AccountType)
```

# Apollo GraphQL Server Setup

We will to set up an Apollo GraphQL server with Node.js that implements a data model for users, accounts, and account types.

The implementation uses a file-based persistence system that stores all data in a JSON file, making it easy to set up without requiring a database. 

This guide shows how to set up a GraphQL server with Apollo Server that provides account information for consumption by an Apollo Client application.

## Project Setup

### 1. Initialize the project

```bash
mkdir graphqldemo
cd graphqldemo
npm init -y
```

### 2. Install dependencies

```bash
npm install apollo-server graphql
```

## File Structure

Create the following file structure:

```
banking-graphql-server/
├── data/
│   └── db.json
├── src/
│   ├── index.js
│   ├── schema.js
│   ├── resolvers.js
│   └── db.js
└── package.json
```

## Implementation

### 1. Sample database file

The data is pre-populated with mock data in data/db.json:

```json
{
  "users": [
    {
      "userId": "user-1",
      "name": "John Doe",
      "email": "john@example.com"
    },
    {
      "userId": "user-2",
      "name": "Jane Smith",
      "email": "jane@example.com"
    }
  ],
  "accounts": [
    {
      "accountId": "acc-1",
      "balance": 1500.75,
      "openDate": "2023-01-15T00:00:00.000Z"
    },
    {
      "accountId": "acc-2",
      "balance": 5250.50,
      "openDate": "2023-02-20T00:00:00.000Z"
    },
    {
      "accountId": "acc-3",
      "balance": 10000,
      "openDate": "2023-03-10T00:00:00.000Z"
    }
  ],
  "accountTypes": [
    {
      "typeId": "type-1",
      "name": "Checking",
      "description": "Everyday banking account with no interest",
      "interestRate": 0
    },
    {
      "typeId": "type-2",
      "name": "Savings",
      "description": "Interest-bearing account for savings",
      "interestRate": 0.02
    },
    {
      "typeId": "type-3",
      "name": "Investment",
      "description": "High-yield investment account",
      "interestRate": 0.05
    }
  ],
  "owns": [
    {
      "userId": "user-1",
      "accountId": "acc-1",
      "accessLevel": "primary"
    },
    {
      "userId": "user-1",
      "accountId": "acc-2",
      "accessLevel": "primary"
    },
    {
      "userId": "user-2",
      "accountId": "acc-3",
      "accessLevel": "primary"
    },
    {
      "userId": "user-2",
      "accountId": "acc-1",
      "accessLevel": "joint"
    }
  ],
  "isType": [
    {
      "accountId": "acc-1",
      "typeId": "type-1"
    },
    {
      "accountId": "acc-2",
      "typeId": "type-2"
    },
    {
      "accountId": "acc-3",
      "typeId": "type-3"
    }
  ]
}
```

### 2. Database access module

src/db.js:

```javascript
const fs = require('fs').promises;
const path = require('path');

const DB_PATH = path.join(__dirname, '../data/db.json');

// Load database
async function loadDb() {
  try {
    const data = await fs.readFile(DB_PATH, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error('Error loading database:', error);
    throw error;
  }
}

// Database read operations
const db = {
  // Get all accounts
  getAccounts: async () => {
    const data = await loadDb();
    return data.accounts;
  },
  
  // Get specific account by ID
  getAccountById: async (accountId) => {
    const data = await loadDb();
    return data.accounts.find(account => account.accountId === accountId);
  },
  
  // Get account type for a specific account
  getAccountType: async (accountId) => {
    const data = await loadDb();
    const relationship = data.isType.find(rel => rel.accountId === accountId);
    
    if (!relationship) return null;
    
    return data.accountTypes.find(type => type.typeId === relationship.typeId);
  },
  
  // Get users of a specific account
  getAccountUsers: async (accountId) => {
    const data = await loadDb();
    const relationships = data.owns.filter(rel => rel.accountId === accountId);
    
    return relationships.map(rel => {
      const user = data.users.find(user => user.userId === rel.userId);
      return {
        ...user,
        accessLevel: rel.accessLevel
      };
    });
  },
  
  // Calculate total balance across all accounts
  getTotalBalance: async () => {
    const data = await loadDb();
    return data.accounts.reduce((total, account) => total + account.balance, 0);
  }
};

module.exports = db;
```

### 3. GraphQL schema

src/schema.js:

```javascript
const { gql } = require('apollo-server');

const typeDefs = gql`
  type User {
    userId: ID!
    name: String!
    email: String!
  }
  
  type Account {
    accountId: ID!
    balance: Float!
    openDate: String!
    accountType: AccountType
    users: [UserWithAccess!]
  }
  
  type AccountType {
    typeId: ID!
    name: String!
    description: String!
    interestRate: Float!
  }
  
  type UserWithAccess {
    userId: ID!
    name: String!
    email: String!
    accessLevel: String!
  }
  
  type AccountSummary {
    accounts: [Account!]!
    totalBalance: Float!
  }
  
  type Query {
    accounts: [Account!]!
    account(accountId: ID!): Account
    accountSummary: AccountSummary!
  }
`;

module.exports = typeDefs;
```

### 4. GraphQL resolvers

src/resolvers.js:

```javascript
const db = require('./db');

const resolvers = {
  Query: {
    accounts: () => db.getAccounts(),
    account: (_, { accountId }) => db.getAccountById(accountId),
    accountSummary: async () => {
      return {
        accounts: await db.getAccounts(),
        totalBalance: await db.getTotalBalance()
      };
    }
  },
  
  Account: {
    accountType: (account) => db.getAccountType(account.accountId),
    users: (account) => db.getAccountUsers(account.accountId)
  }
};

module.exports = resolvers;
```

### 5. Server setup

src/index.js:

```javascript
const { ApolloServer } = require('apollo-server');
const fs = require('fs').promises;
const path = require('path');
const typeDefs = require('./schema');
const resolvers = require('./resolvers');

// Check if DB file exists, if not create it
async function initDb() {
  const dbPath = path.join(__dirname, '../data/db.json');
  try {
    await fs.access(dbPath);
    console.log('Database file exists.');
  } catch (error) {
    console.log('Database file not found. Please create it with mock data.');
    process.exit(1);
  }
}

async function startServer() {
  await initDb();
  
  const server = new ApolloServer({
    typeDefs,
    resolvers,
    formatError: (error) => {
      console.error('GraphQL Error:', error);
      return error;
    }
  });
  
  const { url } = await server.listen(4000);
  console.log(`🚀 Server ready at ${url}`);
}

startServer().catch(error => {
  console.error('Failed to start server:', error);
});
```

## Running the Server

1. Make sure all files are saved in the correct locations.
2. Create the `data/db.json` file with the sample data.
3. Start the server:

```bash
node src/index.js
```

5. The GraphQL server will be available at `http://localhost:4000/` for testing.

## Example Queries for Apollo Client

### Get All Accounts with Details

```graphql
query GetAllAccounts {
  accounts {
    accountId
    balance
    openDate
    accountType {
      name
      description
      interestRate
    }
    users {
      name
      email
      accessLevel
    }
  }
}
```

### Get Account Summary with Total Balance

```graphql
query GetAccountSummary {
  accountSummary {
    accounts {
      accountId
      balance
      accountType {
        name
      }
      users {
        name
        accessLevel
      }
    }
    totalBalance
  }
}
```

### Get Specific Account by ID

```graphql
query GetAccount($accountId: ID!) {
  account(accountId: $accountId) {
    accountId
    balance
    openDate
    accountType {
      name
      description
      interestRate
    }
    users {
      name
      email
      accessLevel
    }
  }
}
```

To pass the accountId to the server, in the variables tab of the Apollo studio, add:

```
{
  "accountId": "acc-1"
}
```

UserWithAccess does not look like will become part of the domain model. It is needed for implementing access level. All other concepts in the schema seems like will end up in the domain model.

## FIBO Subset

Identify the subset of FIBO to import using the current schema

Looking at these concepts, you would need elements from the FIBO (Financial Industry Business Ontology) Business Entities (BE) and Financial Business and Commerce (FBC) domains to effectively map your domain model.

Here's the appropriate FIBO subset for mapping these concepts:

1. **For User**:
   - FIBO BE (Business Entities): Person
   - FIBO BE: Legal Person (if the user can be an organization)
   - FIBO BE: NaturalPerson (for individual users)

2. **For Account**:
   - FIBO FBC (Financial Business and Commerce): Account
   - FIBO FBC: CustomerAccount

3. **For AccountType**:
   - FIBO FBC: AccountSpecification
   - FIBO FBC: AccountTypeEnum (for different account classifications)

4. **For AccountSummary**:
   - FIBO FBC: AccountState
   - FIBO FBC: AccountStatus
   - FIBO FBC: Balance (for summarizing financial position)

5. **For Bank**:
   - FIBO BE: FormalOrganization
   - FIBO FBC: FinancialServiceProvider
   - FIBO FBC: FinancialInstitution
   - FIBO FBC: Bank

Additionally, you would need relationship classes from FIBO to connect these entities:
- FIBO FBC: CustomerRelationship (connecting User to Bank)
- FIBO FBC: AccountProvider (connecting Bank to Account)
- FIBO FBC: AccountIdentifier (for unique account references)
- FIBO FBC: AccountHolder (connecting User to Account)

This subset provides the foundational elements needed to create an ontologically sound domain model that aligns with financial industry standards.

## Import FIBO Subset

To import the FIBO subset into your Neo4j database, you'll need to follow a few steps. Here's a practical approach:

## Step 1: Download the FIBO Ontology Files

First, obtain the FIBO ontology files. The FIBO ontologies are typically available in RDF/OWL format:

```
# FIBO is available from the EDM Council's GitHub repository
git clone https://github.com/edmcouncil/fibo.git
```

## Step 2: Convert RDF/OWL to Neo4j-Compatible Format

You'll need to convert the ontology from RDF/OWL to a format suitable for Neo4j import. The easiest approach is to use the neosemantics (n10s) plugin for Neo4j.

## Step 3: Selective Import of Only the Needed Subset

For your specific domain model, you can create an import script that only pulls in the relevant classes:

## Step 4: Map Your Domain Model to FIBO

After importing the FIBO subset, you'll need to map your specific domain entities to the FIBO concepts:



## Step 5: Create a Visual Graph Representation

To visualize your domain model mapped to FIBO:



## Additional Tips for Working with FIBO in Neo4j

1. **Use namespaces for clarity**: The FIBO ontology has many concepts with similar names across different domains. Preserve the namespaces to avoid confusion.

2. **Consider using APOC procedures**: The APOC library provides powerful tools for working with ontologies in Neo4j.

3. **Create domain-specific views**: After importing the FIBO ontology, create views that make it easier to work with your specific domain model.

4. **Maintain bidirectional mappings**: Ensure you can navigate both from your domain model to FIBO and from FIBO to your domain model.

5. **Document your mappings**: Create a mapping document that explains how each of your domain concepts relates to FIBO concepts.

This approach gives you a precise mapping of your domain model to the relevant FIBO subset, making your database semantically aligned with financial industry standards while keeping it focused on just what you need.

```
// Step 1: Install neosemantics plugin if not already installed
// In your Neo4j Desktop, add the plugin to your project or via Neo4j server configuration

// Step 2: Create RDF import constraints
CREATE CONSTRAINT n10s_unique_uri IF NOT EXISTS FOR (r:Resource) REQUIRE r.uri IS UNIQUE;

// Step 3: Initialize the graph configuration
CALL n10s.graphconfig.init({
  handleVocabUris: 'MAP',
  handleRDFTypes: 'LABELS',
  keepLangTag: false,
  applyNeo4jNaming: true
});

// Step 4: Import specific FIBO modules
// Business Entities (BE) domain
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/BE/LegalEntities/LegalPersons.rdf",
  "RDF/XML"
);

// Import Person definitions
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/BE/Persons/Persons.rdf",
  "RDF/XML"
);

// Financial Business and Commerce (FBC) modules
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/FBC/FinancialInstruments/FinancialInstruments.rdf",
  "RDF/XML"
);

CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/FBC/ProductsAndServices/FinancialProductsAndServices.rdf",
  "RDF/XML"
);

// Import the Account-related modules
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/FBC/ProductsAndServices/ClientsAndAccounts.rdf",
  "RDF/XML"
);

// Import Bank-related modules
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo/FBC/FinancialInstitutions/FinancialInstitutions.rdf",
  "RDF/XML"
);

// Step 5: Verify import
MATCH (c:Class) RETURN c.prefLabel, c.uri LIMIT 10;

// Check specifically for your required concepts
MATCH (c:Class)
WHERE c.prefLabel IN ['Person', 'Account', 'Bank', 'FinancialInstitution', 'AccountSpecification']
RETURN c.prefLabel, c.uri;
```

```
// Create a custom procedure to import only the needed subset
// This assumes you've already initialized the graph config as in the previous script

// Define the FIBO classes we need for our domain model
WITH [
  // User related
  'https://spec.edmcouncil.org/fibo/ontology/BE/Persons/Persons/Person',
  'https://spec.edmcouncil.org/fibo/ontology/BE/LegalEntities/LegalPersons/LegalPerson',
  'https://spec.edmcouncil.org/fibo/ontology/BE/Persons/Persons/NaturalPerson',
  
  // Account related
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/Account',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/CustomerAccount',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountSpecification',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountTypeEnum',
  
  // Account Summary related
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountState',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountStatus',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/Balance',
  
  // Bank related
  'https://spec.edmcouncil.org/fibo/ontology/BE/LegalEntities/FormalOrganizations/FormalOrganization',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/FinancialInstitutions/FinancialServiceProviders/FinancialServiceProvider',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/FinancialInstitutions/FinancialInstitutions/FinancialInstitution',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/FinancialInstitutions/FinancialInstitutions/Bank',
  
  // Relationships
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/CustomerRelationship',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountProvider',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountIdentifier',
  'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountHolder'
] AS fiboClasses

// Import the entire FIBO ontology with a filter to extract only our required classes
CALL n10s.rdf.import.fetch(
  "file:///path/to/fibo-merged.rdf",
  "RDF/XML",
  { 
    classFilter: fiboClasses,
    includeInferredTriples: true,
    fetchRelatedEntities: true
  }
);

// Create indexes for better performance
CREATE INDEX fibo_class_index IF NOT EXISTS FOR (c:Class) ON (c.uri);
CREATE INDEX fibo_resource_index IF NOT EXISTS FOR (r:Resource) ON (r.uri);

// Map to your domain model with more friendly names
MATCH (c:Class)
WHERE c.uri IN fiboClasses
WITH c, 
     CASE 
       WHEN c.uri CONTAINS '/Person' THEN 'User'
       WHEN c.uri CONTAINS '/Account' AND NOT c.uri CONTAINS '/AccountSpecification' THEN 'Account'
       WHEN c.uri CONTAINS '/AccountSpecification' THEN 'AccountType'
       WHEN c.uri CONTAINS '/Bank' THEN 'Bank'
       WHEN c.uri CONTAINS '/Balance' OR c.uri CONTAINS '/AccountState' THEN 'AccountSummary'
       ELSE LAST(SPLIT(c.uri, '/'))
     END AS domainClass
SET c.domainMapping = domainClass;

// Create views for easier querying of your domain model
CALL apoc.meta.subGraph({
  includeLabels: ['Class'],
  filterRelationshipTypes: ['SUBCLASS_OF', 'DOMAIN', 'RANGE']
})
YIELD nodes, relationships
RETURN nodes, relationships;
```

```
// Create your domain model nodes
CREATE (user:DomainModel:User {name: 'UserClass'})
CREATE (account:DomainModel:Account {name: 'AccountClass'})
CREATE (accountType:DomainModel:AccountType {name: 'AccountTypeClass'})
CREATE (accountSummary:DomainModel:AccountSummary {name: 'AccountSummaryClass'})
CREATE (bank:DomainModel:Bank {name: 'BankClass'});

// Create the relationships for your domain model
MATCH (user:User), (account:Account)
CREATE (user)-[:HAS_ACCOUNT]->(account);

MATCH (account:Account), (accountType:AccountType)
CREATE (account)-[:HAS_TYPE]->(accountType);

MATCH (account:Account), (accountSummary:AccountSummary)
CREATE (account)-[:HAS_SUMMARY]->(accountSummary);

MATCH (bank:Bank), (account:Account)
CREATE (bank)-[:PROVIDES]->(account);

MATCH (user:User), (bank:Bank)
CREATE (user)-[:CUSTOMER_OF]->(bank);

// Map your domain model to FIBO concepts
MATCH (user:User), (fiboUser:Class)
WHERE fiboUser.uri = 'https://spec.edmcouncil.org/fibo/ontology/BE/Persons/Persons/Person'
CREATE (user)-[:MAPPED_TO_FIBO]->(fiboUser);

MATCH (account:Account), (fiboAccount:Class)
WHERE fiboAccount.uri = 'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/Account'
CREATE (account)-[:MAPPED_TO_FIBO]->(fiboAccount);

MATCH (accountType:AccountType), (fiboAccountType:Class)
WHERE fiboAccountType.uri = 'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountSpecification'
CREATE (accountType)-[:MAPPED_TO_FIBO]->(fiboAccountType);

MATCH (accountSummary:AccountSummary), (fiboAccountState:Class)
WHERE fiboAccountState.uri = 'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountState'
CREATE (accountSummary)-[:MAPPED_TO_FIBO]->(fiboAccountState);

MATCH (bank:Bank), (fiboBank:Class)
WHERE fiboBank.uri = 'https://spec.edmcouncil.org/fibo/ontology/FBC/FinancialInstitutions/FinancialInstitutions/Bank'
CREATE (bank)-[:MAPPED_TO_FIBO]->(fiboBank);

// Map your domain relationships to FIBO relationships
MATCH (user:User)-[r:HAS_ACCOUNT]->(account:Account),
      (fiboHolder:Class {uri: 'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountHolder'})
CREATE (r)-[:ALIGNED_WITH]->(fiboHolder);

MATCH (bank:Bank)-[r:PROVIDES]->(account:Account),
      (fiboProvider:Class {uri: 'https://spec.edmcouncil.org/fibo/ontology/FBC/ProductsAndServices/ClientsAndAccounts/AccountProvider'})
CREATE (r)-[:ALIGNED_WITH]->(fiboProvider);

// Query to verify your mappings
MATCH (domain:DomainModel)-[m:MAPPED_TO_FIBO]->(fibo:Class)
RETURN domain.name, fibo.prefLabel, fibo.uri;
```

```
// Visualization query for your mapped domain model
MATCH path = (domain:DomainModel)-[:MAPPED_TO_FIBO]->(fibo:Class)
WITH path, domain, fibo
MATCH domainRels = (domain)-[r]->(otherDomain:DomainModel)
RETURN path, domainRels
LIMIT 100;

// Alternative visualization focusing on one concept at a time
// For example, visualizing everything related to Account:
MATCH (account:Account)
CALL apoc.path.expand(account, "MAPPED_TO_FIBO|ALIGNED_WITH|HAS_TYPE|HAS_SUMMARY", "", 1, 3)
YIELD path
RETURN path;
```

## Tasks

- Bank Name is missing
